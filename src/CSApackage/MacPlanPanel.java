/*
 * MacPlanPanel.java
 *
 * Created on June 18, 2007, 10:24 AM
 */

package CSApackage;

import static CSApackage.V_to_mu_plot.dashed;
import java.awt.*;
import java.text.*;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author  Owner
 */
public class MacPlanPanel extends javax.swing.JPanel
{
  public NumberFormat m_IntFormat = NumberFormat.getIntegerInstance();  
  
  V_to_mu_plot V_to_mu_plotPanel = null;
  private Mac theMac = null;
  
  protected int numCMCols = 10;
  protected final int numCMRows = 1;
  
  MainCSA_demoPanel m_Controller = null;
  Color old_background_color; 
  
  int mouse_X;
  int mouse_Y;
  private int Focused_CM_Index = 3;
  
  
  /**
   * Creates new mac Panel
   */
  public MacPlanPanel(int numCMs)
  {    
    m_IntFormat.setMaximumIntegerDigits( 2 );    
    initComponents();
  }
  
  public MacPlanPanel()
  {
    this(6);    
  }
  
  public void SetController ( MainCSA_demoPanel controller )
  {
    m_Controller = controller;
  }
   
  
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    addMouseListener(new java.awt.event.MouseAdapter() {
      public void mouseClicked(java.awt.event.MouseEvent evt) {
        formMouseClicked(evt);
      }
    });
    setLayout(null);
  }// </editor-fold>//GEN-END:initComponents

  private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
    // TODO add your handling code here:
    mouse_X = evt.getX();
    mouse_Y = evt.getY();  
    
    // Determine which CM the user clicked on
    
    numCMCols = (int) Math.ceil((double) theMac.Q / numCMRows);
    
    overallHeight = getHeight();    
    int single_CM_block_ht = (int)(overallHeight / numCMRows) - vertMargin * 2;
    int CM_chart_ht = (int)((single_CM_block_ht - CM_label_vert_space) / 2) ;
    int CM_chart_y_range_ht_pix = CM_chart_ht - chartInternalTopMargin;
    int CM_chart_half_y_range_ht_pix = (int)(CM_chart_y_range_ht_pix / 2f);
    
    // determine widths of things
    overallWidth = getWidth();
    CM_width = (overallWidth - leftMargin - x_AxisRightBufferPixels) / numCMCols;
    CM_width -= horizSpaceCM;    
    barZoneWidth = CM_width / Math.max(theMac.K,2);                  // need to make sure never divide by zero just ot avoid error when we delete all cells.
    barWidth = barZoneWidth - 2 * barHorizMargin;    
    
    // but we really don't want bars to get too wide so we have an upper limit on bar width.
    // we check that here and recompute the other widths based on the max bar width.
    
    if (barWidth > maxBarWidth)
    {
      barWidth = maxBarWidth;
      barZoneWidth = barWidth + 2 * barHorizMargin;
//      CM_width = K * barZoneWidth;
    }
    
    int xpos = 0;
    int ypos = CM_chart_ht + vertMargin;
    int barHeight = 0;
    boolean found = false;
    
    // g2.drawRect(xpos - 3, ypos - CM_chart_ht, CM_width + 6, 2 * CM_chart_ht); 
    
    int q = 0;
    for ( int row = 0; row < numCMRows; row++ )
    {
      xpos = leftMargin;
      int col = 0;
      while (col < numCMCols && q < theMac.Q - 1)
      {
        // q is the index of CM
        q = row * numCMCols + col;
        
        if (mouse_X > xpos - 3 && mouse_X < xpos + CM_width + 6)
        {
          Focused_CM_Index = q;
          found = true;
          break;
        }
        
        xpos += CM_width + horizSpaceCM;        
        col++;
      }
      if (found)
        break;
      ypos += 2 * CM_chart_ht + CM_label_vert_space;
    }
    
    this.m_Controller.updateOtherPanelsConsistently();
    ((V_to_mu_plot)this.V_to_mu_plotPanel).repaint();
    
    repaint();
  }//GEN-LAST:event_formMouseClicked
  
  public void set_plot_class( V_to_mu_plot plotPanel ) { V_to_mu_plotPanel = plotPanel; }
    
  
  // constant/vars for drawing
  
  int overallHeight = 200;  
  int x_AxisRightBufferPixels = 20;
  int overallWidth = 500;  
  int vertMargin = 15;
  int horizSpaceCM = 14;
  int CM_label_vert_space = 40;
  int cellDiameter = 10;
  int cellRadius = 5;
  int barWidth = 5;
  int maxBarWidth = 10;
  int barHorizMargin = 1;
  int barZoneWidth = barWidth + 2 * barHorizMargin;
  int chartInternalTopMargin = 8;
  int leftMargin = 35;
  int CM_width = 9 * 2 * barWidth;
  int CM_height = 60;
  int CM_halfWidth = 20;
  int CM_halfHeight = 20;
  
  Color nonMaxVColor = Color.lightGray;
  Color maxVColor = Color.black;
  Color irrelevantColor = Color.lightGray;
  Color correctWinColor = Color.black;
  Color incorrectWinColor = Color.black;
  Color incorrectLossColor = new Color(255, 153, 153); // Color.red;  
//  Color cellColor = new Color(192, 192, 192);
  
  Font axisValuesFont = new Font("Serif", Font.BOLD, 14);
  Font axisVarFont = new Font("Serif", Font.BOLD | Font.ITALIC, 20);
  Font axisVarFontLarge = new Font("Serif", Font.BOLD | Font.ITALIC, 26);
  Font CM_LabelFont = new Font("Serif", Font.BOLD, 14);
  
  protected void paintComponent(java.awt.Graphics g)
  {
    super.paintComponent(g);
    Graphics2D g2 = (Graphics2D) g;        
    
    if ( theMac == null )  { return; }
    
    // Right now, we just show all CMs in one row
    
    numCMCols = (int) Math.ceil((double) theMac.Q / numCMRows);
    
    overallHeight = getHeight();    
    int single_CM_block_ht = (int)(overallHeight / numCMRows) - vertMargin * 2;
    int CM_chart_ht = (int)((single_CM_block_ht - CM_label_vert_space) / 2) ;
    int CM_chart_y_range_ht_pix = CM_chart_ht - chartInternalTopMargin;
    int CM_chart_half_y_range_ht_pix = (int)(CM_chart_y_range_ht_pix / 2f);
   
    int xpos = 0;
    int ypos = CM_chart_ht + vertMargin;
    int barHeight = 0;
    
    // get default background color for this panel
    old_background_color = this.getBackground();
    
    // determine widths of things
    overallWidth = getWidth();
    CM_width = (overallWidth - leftMargin - x_AxisRightBufferPixels) / numCMCols;
    CM_width -= horizSpaceCM;    
    barZoneWidth = CM_width / Math.max(theMac.K,2);                  // need to make sure never divide by zero just ot avoid error when we delete all cells.
    barWidth = barZoneWidth - 2 * barHorizMargin;    
    
    // but we really don't want bars to get too wide so we have an upper limit on bar width.
    // we check that here and recompute the other widths based on the max bar width.
    
    if (barWidth > maxBarWidth)
    {
      barWidth = maxBarWidth;
      barZoneWidth = barWidth + 2 * barHorizMargin;
//      CM_width = K * barZoneWidth;
    }
    
    // Fill out all the CMs. This code is a double loop to make it easy if we want
    // to change to using two rows to show CMs.
    
    int q = 0;
    for ( int row = 0; row < numCMRows; row++ )
    {
      xpos = leftMargin;
      int col = 0;
      while (col < numCMCols && q < theMac.Q - 1)
      {
        // q is the index of CM
        q = row * numCMCols + col;
        
        // Paint background diff color for the Focused CM than for the rest.  That background will be same as for
        // the sigmoid graph at upper left.  This tells the user that the values in the sigmoid graph
        // correspond to those in the Focused CM.  The V vals in the other CMs are selected randomly from distributions.
        
        if (q == this.Focused_CM_Index)
          g2.setColor(m_Controller.first_CM_background);
        else
          g2.setColor(old_background_color);
        
        g2.fillRect(xpos - 3, ypos - CM_chart_ht, CM_width + 6, 2 * CM_chart_ht); 
        
        // draw box around the area for one CM (which includes the two stacked charts)        
        g2.setColor(Color.BLUE);
        g2.drawRect(xpos - 3, ypos - CM_chart_ht, CM_width + 6, 2 * CM_chart_ht); 
        
        g2.drawLine(xpos, ypos, xpos + CM_width, ypos);                                                             // draw x-axis for rho bar graph for the CM.
        
        g2.setColor( Color.BLACK );
        g2.setFont(axisVarFontLarge);
        g2.drawString("\u03c1", leftMargin/2 - 8, ypos - CM_chart_half_y_range_ht_pix);
          
        //// Draw the rho bars.
        
        g2.setColor( Color.BLACK );    
        
        boolean hasCorrectWinner = (theMac.maxV_index.get(q) == theMac.winnerIndex.get(q));
        
        for ( int c = 0; c < theMac.K; c++ )     
        {
          if (c == theMac.winnerIndex.get(q))
          {
            if (hasCorrectWinner)
              g2.setColor( correctWinColor );
            else
              g2.setColor( incorrectWinColor );
          }
          else
          {
            if (c == theMac.maxV_index.get(q))
              g2.setColor( incorrectLossColor );
            else
              g2.setColor( irrelevantColor );
          }
          
          barHeight = (int) ( ( theMac.mu.get(q).get(c) / theMac.muSum.get(q) ) * CM_chart_y_range_ht_pix );          
          g2.fillRect(xpos + c * barZoneWidth * barHorizMargin, ypos - barHeight, barWidth, barHeight );
        }
        g2.setColor( Color.BLACK ); // reset to sane color
        
        g2.drawLine(xpos, ypos + CM_chart_ht, xpos + CM_width, ypos + CM_chart_ht );       // draw x-axis for V bar graph for the CM.
        g2.drawString("V", leftMargin/2 - 8, ypos + (int)(CM_chart_ht / 2) + vertMargin);
        
        //// draw the V bars.  This is done in two loops and a middle block because the winner's bar is drawn in a different color.
        
        if (theMac.K > 0)
        {
          g2.setColor( nonMaxVColor );
          for ( int c = 0; c < theMac.maxV_index.get(q); c++ )                       
          {
            barHeight = (int) ( theMac.V.get(q).get(c) * CM_chart_y_range_ht_pix );
            g2.fillRect(xpos + c * barZoneWidth * barHorizMargin, ypos + CM_chart_ht - barHeight, barWidth, barHeight );
          }

          g2.setColor( maxVColor );
          barHeight = (int) ( theMac.V.get(q).get(theMac.maxV_index.get(q)) * CM_chart_y_range_ht_pix );
          g2.fillRect(xpos + theMac.maxV_index.get(q) * barZoneWidth * barHorizMargin, ypos + CM_chart_ht - barHeight, barWidth, barHeight );

          g2.setColor( nonMaxVColor );
          for ( int c = theMac.maxV_index.get(q) + 1; c < theMac.K; c++ )
          {
            barHeight = (int) ( theMac.V.get(q).get(c) * CM_chart_y_range_ht_pix );
            g2.fillRect(xpos + c * barZoneWidth * barHorizMargin, ypos + CM_chart_ht - barHeight, barWidth, barHeight );
          }
        }
        
        // Draw faint horizontal lines to show crosstalk limits.
    
        int max_V_in_pixels = 0;
        if (m_Controller != null)
        {
          Stroke oldStroke = g2.getStroke();
          g2.setStroke(dashed);

          if (m_Controller.isCrossTalkRelativeToCurrentMax_V())
            max_V_in_pixels = (int) (CM_chart_y_range_ht_pix * theMac.GetWinner_V_Val());
          else
            max_V_in_pixels = (int) (CM_chart_y_range_ht_pix * 1);
          
          g2.setColor( m_Controller.colorLowCrosstalkLimit );
          int min_crosstalk_y = ypos + CM_chart_ht - (int)(theMac.GetCrossTalkLowLimFactor() * max_V_in_pixels);
          g2.drawLine(xpos, min_crosstalk_y, xpos + CM_width, min_crosstalk_y );
          
          g2.setColor( m_Controller.colorHighCrosstalkLimit );
          int max_crosstalk_y = ypos + CM_chart_ht - (int)(theMac.GetCrossTalkHighLimFactor() * max_V_in_pixels);
          g2.drawLine(xpos, max_crosstalk_y, xpos + CM_width, max_crosstalk_y );
          
          g2.setStroke(oldStroke);
        }
        
        g2.setColor( Color.BLACK ); // reset to sane color
        g2.setFont(CM_LabelFont);
        g2.drawString("CM " + m_IntFormat.format(q + 1 ), xpos + (int) ( CM_width / 2 ) - 15, ypos + CM_chart_ht + 25 );            // draw q label under box
        
        xpos += CM_width + horizSpaceCM;
        
        col++;
      }
      
      ypos += 2 * CM_chart_ht + CM_label_vert_space;
    }    
  }


  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables

  /**
   * @return the numCMRows
   */
  public int getNumCMRows()
  {
    return numCMRows;
  }

  /**
   * @return the numCMCols
   */
  public int getNumCMCols()
  {
    return numCMCols;
  }

  /**
   * @param numCMCols the numCMCols to set
   */
  public void setNumCMCols(int numCMCols)
  {
    this.numCMCols = numCMCols;
  }

  /**
   * @return the theMac
   */
  public Mac getTheMac() {
    return theMac;
  }

  /**
   * @param theMac the theMac to set
   */
  public void setTheMac(Mac theMac) {
    this.theMac = theMac;
  }

  /**
   * @return the Focused_CM_Index
   */
  public int getFocused_CM_Index() {
    return Focused_CM_Index;
  }

  /**
   * @param Focused_CM_Index the Focused_CM_Index to set
   */
  public void setFocused_CM_Index(int Focused_CM_Index) {
    this.Focused_CM_Index = Focused_CM_Index;
  }

  
  
}
